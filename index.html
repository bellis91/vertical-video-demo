<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Responsive Vertical/Horizontal Player</title>

  <!-- Flowplayer Native + HLS plugin -->
  <link rel="stylesheet" href="https://cdn.flowplayer.com/releases/native/3/stable/style/flowplayer.css" />
  <script src="https://cdn.flowplayer.com/releases/native/3/stable/flowplayer.min.js" defer></script>
  <script src="https://cdn.flowplayer.com/releases/native/3/stable/plugins/hls.min.js" defer></script>
  <script src="https://cdn.flowplayer.com/releases/native/3/stable/plugins/qsel.min.js"></script>

  <style>
    :root { color-scheme: dark; }
    html, body { margin: 0; padding: 0; background: #000; }
    .wrap { max-width: 960px; margin: 0 auto; padding: 16px; }
    .stage.flowplayer {
      position: relative; width: 100%;
      aspect-ratio: 16 / 9;            /* Desktop/laptop default */
      background:#000; border-radius:16px; overflow:hidden;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    /* Phones / portrait â†’ 9:16 container */
    @media (max-width: 768px), (orientation: portrait) {
      .stage.flowplayer { aspect-ratio: 9 / 16; }
    }
    /* Fit rules: contain for 16:9 desktop, cover for 9:16 mobile */
    .stage.flowplayer video { width:100%; height:100%; object-fit: contain; object-position: 50% 50%; }
    @media (max-width: 768px), (orientation: portrait) {
      .stage.flowplayer video { object-fit: cover; }
    }
    /* Unmute button for mobile */
    #unmuteBtn {
      position:absolute; right:12px; bottom:12px; z-index:40;
      padding:8px 10px; border:0; border-radius:10px;
      font-weight:700; background:#1e90ff; color:#fff; cursor:pointer;
      display:none;
    }
  </style>
</head>
<body>
  <main class="wrap">
    <div id="player" class="flowplayer stage">
      <button id="unmuteBtn">ðŸ”Š Unmute</button>
    </div>
  </main>

  <script defer>
    window.addEventListener("DOMContentLoaded", () => {
      if (!window.flowplayer) { console.error("Flowplayer not loaded"); return; }

      // Works from ANY device on your LAN (Mac, iPhone, etc.)
      const HLS_URL = "https://cdn3.wowza.com/1/MzRHWlBka0Zxa2h1/SjR1K3oy/hls/live/playlist.m3u8";

      // Your Flowplayer token (required on non-localhost origins)
      const token =
        "eyJraWQiOiIwWE44RnRTYkQxblYiLCJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9.eyJjIjoie1wiYWNsXCI6MzgsXCJpZFwiOlwiMFhOOEZ0U2JEMW5WXCJ9IiwiaXNzIjoiRmxvd3BsYXllciJ9.wHlyQZ86rIHD8ldgnpiWbmFBmR4zt_3FSj78GMk7lfQ1es7K8y0MuHzbqcJfp0lm6LcUbUkQ5PsazIsAybxivg";

      const player = flowplayer("#player", {
        token,
        src: HLS_URL,
        autoplay: true,
        muted: true,              // required for mobile autoplay
        live: true,
        hls: {
          debug: false,
          lowLatencyMode: true,
          xhrSetup: (xhr) => { xhr.withCredentials = false; } // no cookies â†’ fewer CORS surprises
        },
        keyboard: false,
        mutedAutoplay: "try"
      });

      // Make the underlying <video> inline + CORS-friendly, show Unmute on mobile
      player.on("ready", () => {
        const v = player.container.querySelector("video");
        if (v) {
          v.setAttribute("playsinline", "");
          v.setAttribute("crossorigin", "anonymous");
        }
        const btn = document.getElementById("unmuteBtn");
        if (btn && v) {
          btn.style.display = "block";
          btn.onclick = async () => { v.muted = false; try { await v.play(); } catch {} btn.style.display = "none"; };
        }
      });

      // Prefer orientation-appropriate levels (landscape on desktop, portrait on phones)
      function wantPortraitViewport() {
        return window.matchMedia("(max-width: 768px), (orientation: portrait)").matches;
      }

      player.on("hlsManifestParsed", () => {
        const hls = player.engine && player.engine.hls;
        if (!hls || !Array.isArray(hls.levels)) return; // Safari may be native, no hls.js instance

        const levels = hls.levels;
        const portrait = [], landscape = [];
        levels.forEach((l, i) => {
          const isPortrait = (l.height && l.width) ? (l.height > l.width)
            : (l.attrs && l.attrs.RESOLUTION && /x\s*1920\b/i.test(String(l.attrs.RESOLUTION)));
          (isPortrait ? portrait : landscape).push(i);
        });

        const chooseBest = (set) => {
          if (!set.length) return -1;
          return set.reduce((best, i) => {
            const a = levels[best] || {width:0, height:0};
            const b = levels[i];
            const ap = (a.width||0) * (a.height||0);
            const bp = (b.width||0) * (b.height||0);
            return bp > ap ? i : best;
          }, set[0]);
        };

        const pickForViewport = () => {
          const allowed = wantPortraitViewport() ? portrait : landscape;
          const target = chooseBest(allowed);
          if (target >= 0) {
            if ("startLevel" in hls && hls.startLevel === -1) hls.startLevel = target;
            hls.nextLevel = target;
          }
        };

        pickForViewport();

        // If hls.js is present, gently keep within the chosen orientation set
        if (typeof hls.on === "function") {
          const allowedSetPortrait = new Set(portrait);
          const allowedSetLandscape = new Set(landscape);
          hls.on(Hls.Events.LEVEL_SWITCHING, (_e, data) => {
            const allow = wantPortraitViewport() ? allowedSetPortrait : allowedSetLandscape;
            if (!allow.has(data.level)) {
              const fallback = chooseBest(Array.from(allow));
              if (fallback >= 0) hls.nextLevel = fallback;
            }
          });
        }

        // React to viewport changes
        const reselect = () => pickForViewport();
        window.addEventListener("resize", reselect, { passive: true });
        window.addEventListener("orientationchange", reselect, { passive: true });
      });
    });
  </script>
</body>
</html>
